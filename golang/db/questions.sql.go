// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: questions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/jackc/pgtype"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (bac_hoc_id, question_text, option1, option2, option3, option4, explanation) 
  VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, bac_hoc_id, question_text, explanation, option1, option2, option3, option4
`

type CreateQuestionParams struct {
	BacHocID     string         `json:"bac_hoc_id"`
	QuestionText string         `json:"question_text"`
	Option1      pgtype.JSONB   `json:"option1"`
	Option2      pgtype.JSONB   `json:"option2"`
	Option3      pgtype.JSONB   `json:"option3"`
	Option4      pgtype.JSONB   `json:"option4"`
	Explanation  sql.NullString `json:"explanation"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.BacHocID,
		arg.QuestionText,
		arg.Option1,
		arg.Option2,
		arg.Option3,
		arg.Option4,
		arg.Explanation,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.BacHocID,
		&i.QuestionText,
		&i.Explanation,
		&i.Option1,
		&i.Option2,
		&i.Option3,
		&i.Option4,
	)
	return i, err
}

const deleteQuestionByIDs = `-- name: DeleteQuestionByIDs :exec
DELETE FROM questions WHERE id = $1
`

func (q *Queries) DeleteQuestionByIDs(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteQuestionByIDs, id)
	return err
}

const findAllQuestions = `-- name: FindAllQuestions :many
SELECT id, bac_hoc_id, question_text, explanation, option1, option2, option3, option4 FROM questions ORDER BY id
`

func (q *Queries) FindAllQuestions(ctx context.Context) ([]Question, error) {
	rows, err := q.db.Query(ctx, findAllQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.BacHocID,
			&i.QuestionText,
			&i.Explanation,
			&i.Option1,
			&i.Option2,
			&i.Option3,
			&i.Option4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findQuestionByIDs = `-- name: FindQuestionByIDs :one
SELECT id, bac_hoc_id, question_text, explanation, option1, option2, option3, option4 FROM questions WHERE id = $1 LIMIT 1
`

func (q *Queries) FindQuestionByIDs(ctx context.Context, id int64) (Question, error) {
	row := q.db.QueryRow(ctx, findQuestionByIDs, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.BacHocID,
		&i.QuestionText,
		&i.Explanation,
		&i.Option1,
		&i.Option2,
		&i.Option3,
		&i.Option4,
	)
	return i, err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions 
SET 
    bac_hoc_id = $1,
    question_text = $2,
    option1 = $3,
    option2 = $4,
    option3 = $5,
    option4 = $6,
    explanation = $7 
WHERE id = $8
RETURNING id, bac_hoc_id, question_text, explanation, option1, option2, option3, option4
`

type UpdateQuestionParams struct {
	BacHocID     string         `json:"bac_hoc_id"`
	QuestionText string         `json:"question_text"`
	Option1      pgtype.JSONB   `json:"option1"`
	Option2      pgtype.JSONB   `json:"option2"`
	Option3      pgtype.JSONB   `json:"option3"`
	Option4      pgtype.JSONB   `json:"option4"`
	Explanation  sql.NullString `json:"explanation"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.BacHocID,
		arg.QuestionText,
		arg.Option1,
		arg.Option2,
		arg.Option3,
		arg.Option4,
		arg.Explanation,
		arg.ID,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.BacHocID,
		&i.QuestionText,
		&i.Explanation,
		&i.Option1,
		&i.Option2,
		&i.Option3,
		&i.Option4,
	)
	return i, err
}
