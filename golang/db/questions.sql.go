// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: questions.sql

package db

import (
	"context"
	"database/sql"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (categoryid, text, option1id, option2id, option3id, option4id, explanation) 
  VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, categoryid, text, option1id, option2id, option3id, option4id, explanation
`

type CreateQuestionParams struct {
	Categoryid  int32          `json:"categoryid"`
	Text        string         `json:"text"`
	Option1id   int32          `json:"option1id"`
	Option2id   int32          `json:"option2id"`
	Option3id   int32          `json:"option3id"`
	Option4id   int32          `json:"option4id"`
	Explanation sql.NullString `json:"explanation"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.Categoryid,
		arg.Text,
		arg.Option1id,
		arg.Option2id,
		arg.Option3id,
		arg.Option4id,
		arg.Explanation,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Categoryid,
		&i.Text,
		&i.Option1id,
		&i.Option2id,
		&i.Option3id,
		&i.Option4id,
		&i.Explanation,
	)
	return i, err
}

const deleteQuestionByIDs = `-- name: DeleteQuestionByIDs :exec
DELETE FROM questions WHERE id = $1
`

func (q *Queries) DeleteQuestionByIDs(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteQuestionByIDs, id)
	return err
}

const findAllQuestions = `-- name: FindAllQuestions :many
SELECT id, categoryid, text, option1id, option2id, option3id, option4id, explanation FROM questions ORDER BY id
`

func (q *Queries) FindAllQuestions(ctx context.Context) ([]Question, error) {
	rows, err := q.db.Query(ctx, findAllQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Categoryid,
			&i.Text,
			&i.Option1id,
			&i.Option2id,
			&i.Option3id,
			&i.Option4id,
			&i.Explanation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findQuestionByIDs = `-- name: FindQuestionByIDs :one
SELECT id, categoryid, text, option1id, option2id, option3id, option4id, explanation FROM questions WHERE id = $1 LIMIT 1
`

func (q *Queries) FindQuestionByIDs(ctx context.Context, id int64) (Question, error) {
	row := q.db.QueryRow(ctx, findQuestionByIDs, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Categoryid,
		&i.Text,
		&i.Option1id,
		&i.Option2id,
		&i.Option3id,
		&i.Option4id,
		&i.Explanation,
	)
	return i, err
}

const updateQuestionExplain = `-- name: UpdateQuestionExplain :one
UPDATE questions SET explanation = $1 WHERE id = $2 RETURNING id, categoryid, text, option1id, option2id, option3id, option4id, explanation
`

type UpdateQuestionExplainParams struct {
	Explanation sql.NullString `json:"explanation"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateQuestionExplain(ctx context.Context, arg UpdateQuestionExplainParams) (Question, error) {
	row := q.db.QueryRow(ctx, updateQuestionExplain, arg.Explanation, arg.ID)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Categoryid,
		&i.Text,
		&i.Option1id,
		&i.Option2id,
		&i.Option3id,
		&i.Option4id,
		&i.Explanation,
	)
	return i, err
}
